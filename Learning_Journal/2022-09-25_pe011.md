# Project Euler #11: Largest product in a grid

![Problem](./pictures/pe011_problem.png)

## Initial Design:
1) Copy the 20x20 grid of numbers into a format that python can access (a 2-dimensional list)
2) Define a function to calculate the product of 4 numbers horizontally
3) Define a function to calculate the product of 4 numbers vertically
4) Define a function to calculate the product of 4 numbers by both diagonals
5) Find the maximum of all products as our answer


# Progress
## Reading data into a 2-dimensional list
Initially, the matrix was defined using the code below. 

```py
f = open("pe011-test.txt")
contents = f.read()
f.close()

rows = (contents.split('\n'))

matrix = []
for row in rows:
    matrix.append([int(num) for num in row.split(' ')])
```
You can see that we read in a txt file and split rows by new line (generating an array of numbers separated by a space). That could then be further split and appended into an empty array using list comprehension.

This gave us the following (using a small 5x5 testcase matrix):
```
Out[66]: 
[[1, 2, 3, 4, 5],
 [6, 7, 8, 9, 10],
 [11, 12, 13, 14, 15],
 [21, 22, 23, 24, 25],
 [16, 17, 18, 19, 20]]
 ```

 ## Horizontal product function
 ```py
 def product_of_four(list_of_four):
    product = 1
    for num in list_of_four:
        product *= num
    return product


def horizontal_row_product(row):
    product_array = []
    first_number = 0
    second_number = 1
    third_number = 2
    fourth_number = 3

    while fourth_number < len(row):
        multiplicants = [
            row[first_number], row[second_number], row[third_number],
            row[fourth_number]
        ]
        first_number += 1
        second_number += 1
        third_number += 1
        fourth_number += 1
        product_array.append(product_of_four(multiplicants))
        print(product_array)
    return max(product_array)


def horizontal_matrix(matrix):
    product_array = []
    for row in matrix:
        product_array.append(horizontal_row_product(row))
    print(f'product_array is: {product_array}')
    return max(product_array)
```
Output:
```
[24]
[24, 120]
[3024]
[3024, 5040]
[24024]
[24024, 32760]
[255024]
[255024, 303600]
[93024]
[93024, 116280]
product_array is: [120, 5040, 32760, 303600, 116280]

answer is 303600
```
For each row in our 2-D array, we can identify 4 numbers. The while-loop allows us to actually identify these numbers for each row, advancing each number by 1. 1st number, 2nd number, etc are actually better labeled as 1st **index**, second **index**, which would eliminate some ambiguity.

Calling the horizontal_matrix function was met with an error. We had mistakenly had product_array = [] inside of the for loop. This gave us only the maximum for the last array in our 5x5 test grid.

The mistake:

```py
def horizontal_matrix(matrix):    
    for row in matrix:
    product_array = []
        product_array.append(horizontal_row_product(row))
    print(f'product_array is: {product_array}')
    return max(product_array)

```
mistake output:
```
[24]
[24, 120]
[3024]
[3024, 5040]
[24024]
[24024, 32760]
[255024]
[255024, 303600]
[93024]
[93024, 116280]
product_array is: [116280]

answer is 116280
```
 ## Vertical product function
 2022/09/29

 I've been working on this during my morning coding sessions and sometimes during lunch. Finally! A breakthrough!

 The challenge for the Vertical product function was to make the function widely applicable to other situations. 

 I wanted to take the first 4 (or any number) of digits in a column (1 through 21 in column 1), and (what was kind of tricky) then take the **next** 4 numbers 6-16. As soon as the bottom of the matrix was captured, then the column would switch over.

Test matrix:
 ```
 [[1, 2, 3, 4, 5],
 [6, 7, 8, 9, 10],
 [11, 12, 13, 14, 15],
 [21, 22, 23, 24, 25],
 [16, 17, 18, 19, 20]]
 ```

 My friend offered this illustration to guide me through what indices were required to identify the proper matrix numbers:
```
column 1 initial 4...
# [0][0] = 1
# [1][0] = 6
# [2][0] = 11
# [3][0] = 21

Then column 1 for the next 4...
# [1][0]
# [2][0]
# [3][0]
# [4][0]

Then column 2 for initial 4...
# [0][1]
# [1][1]
# [2][1]
# [3][1]

... and so on
```

From this, I got the idea to use a for-loop to scan through each column using range(len(matrix[0])). This iterates through the number of items in row #0 (which should equal columns). With the column indices addressed, I wanted to grab 4 numbers for each column, the next 4 numbers, etc.

This was a bit challenging. I realized that what I wanted was a **range** of numbers 4 that would advance 1 each until I got to the bottom of the matrix. I set up some variables: starting_row_index, and ending_row_index + NUMBERS_TO_MULTIPLY. This capitalized (parameter?, variable?) was meant to allow the user to specify how many numbers to capture. These two variables then allowed me to set up my ranges. A while loop constrained the selection of my 4 numbers which were compiled into another variable called multiplicants.

Ultimately, the code looks like the following:
```py
NUMBERS_TO_MULTIPLY = 4 # (actually 4)

for col_index in range(len(matrix[0])):       
    starting_row_index = 0
    ending_row_index = starting_row_index + NUMBERS_TO_MULTIPLY
    print(f"\ncol_index: {col_index}")
    while ending_row_index < len(matrix)+1:
        multiplicants = []
        print(f"starting number is {matrix[starting_row_index][col_index]}")
        print(f"The range is: {starting_row_index}, {ending_row_index}")
        for number in range(starting_row_index,ending_row_index):
            multiplicants.append(matrix[number][col_index])
        print(multiplicants)
        
        starting_row_index +=1
        ending_row_index +=1
        
```
output:
```
col_index: 0
starting number is 1
The range is: 0, 4
[1, 6, 11, 21]
starting number is 6
The range is: 1, 5
[6, 11, 21, 16]

col_index: 1
starting number is 2
The range is: 0, 4
[2, 7, 12, 22]
starting number is 7
The range is: 1, 5
[7, 12, 22, 17]
...
```
This is great! the print statements show me that the range is advancing properly and generating arrays of 4 numbers.